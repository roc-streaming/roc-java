// Code generated by bindgen.py from roc-streaming/bindgen
// roc-toolkit git tag: v0.3.0, commit: 57b932b8

package org.rocstreaming.roctoolkit;

import java.time.Duration;
import lombok.*;

/**
 * Receiver configuration.
 * <p>
 * RocReceiverConfig object can be instantiated with {@link RocReceiverConfig#builder()}.
 *
 * @see RocReceiver
 */
@Getter
@Builder(builderClassName = "Builder", toBuilder = true)
@ToString
@EqualsAndHashCode
public class RocReceiverConfig {

    /**
     * The encoding used in frames returned by receiver.
     * <p>
     * Frame encoding defines sample format, channel layout, and sample rate in local frames
     * returned by receiver to user. Should be set (zero value is invalid).
     */
    private MediaEncoding frameEncoding;

    /**
     * Clock source.
     * <p>
     * Defines whether read operation will be blocking or non-blocking. If zero,
     * {@link ClockSource#EXTERNAL} is used.
     */
    private ClockSource clockSource;

    /**
     * Clock synchronization backend.
     * <p>
     * Defines how sender and receiver clocks are synchronized. If zero, default value is
     * used.
     */
    private ClockSyncBackend clockSyncBackend;

    /**
     * Clock synchronization profile.
     * <p>
     * Defines what latency and network jitter are tolerated. If zero, default value is used.
     */
    private ClockSyncProfile clockSyncProfile;

    /**
     * Resampler backend.
     * <p>
     * Affects CPU usage, quality, and clock synchronization precision. If zero, default
     * value is used.
     */
    private ResamplerBackend resamplerBackend;

    /**
     * Resampler profile.
     * <p>
     * Affects CPU usage and quality. If zero, default value is used.
     */
    private ResamplerProfile resamplerProfile;

    /**
     * Target latency, in nanoseconds.
     * <p>
     * The session will not start playing until it accumulates the requested latency. Then,
     * if clock synchronization is enabled, the session will adjust its clock to keep actual
     * latency as close as possible to the target latency. If zero, default value is used.
     */
    private Duration targetLatency;

    /**
     * Maximum allowed delta between current and target latency, in nanoseconds.
     * <p>
     * If session latency differs from the target latency by more than given value, the
     * session is terminated (it can then automatically restart). Receiver itself is not
     * terminated; if there are no sessions, it will produce zeros. If zero, default value is
     * used.
     */
    private Duration latencyTolerance;

    /**
     * Timeout for the lack of playback, in nanoseconds.
     * <p>
     * If there is no playback during this period, the session is terminated (it can then
     * automatically restart). Receiver itself is not terminated; if there are no sessions,
     * it will produce zeros. This mechanism allows to detect dead, hanging, or incompatible
     * clients that generate unparseable packets. If zero, default value is used. If
     * negative, the timeout is disabled.
     */
    private Duration noPlaybackTimeout;

    /**
     * Timeout for choppy playback, in nanoseconds.
     * <p>
     * If there is constant stuttering during this period, the session is terminated (it can
     * then automatically restart). Receiver itself is not terminated; if there are no
     * sessions, it will produce zeros. This mechanism allows to detect situations when
     * playback continues but there are frequent glitches, for example because there is a
     * high ratio of late packets. If zero, default value is used. If negative, the timeout
     * is disabled.
     */
    private Duration choppyPlaybackTimeout;

    /**
     * Construct builder for {@link RocReceiverConfig}.
     */
    public static RocReceiverConfig.Builder builder() {
        return new RocReceiverConfigValidator();
    }
}
