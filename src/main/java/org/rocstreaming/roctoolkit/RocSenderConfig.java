// Code generated by bindgen.py from roc-streaming/bindgen
// roc-toolkit git tag: v0.3.0, commit: 57b932b8

package org.rocstreaming.roctoolkit;

import java.time.Duration;
import lombok.*;

/**
 * Sender configuration.
 * <p>
 * RocSenderConfig object can be instantiated with {@link RocSenderConfig#builder()}.
 *
 * @see RocSender
 */
@Getter
@Builder(builderClassName = "Builder", toBuilder = true)
@ToString
@EqualsAndHashCode
public class RocSenderConfig {

    /**
     * The encoding used in frames passed to sender.
     * <p>
     * Frame encoding defines sample format, channel layout, and sample rate in local frames
     * created by user and passed to sender. Should be set (zero value is invalid).
     */
    private MediaEncoding frameEncoding;

    /**
     * The encoding used for packets produced by sender.
     * <p>
     * Packet encoding defines sample format, channel layout, and sample rate in network
     * packets. If packet encoding differs from frame encoding, conversion is performed
     * automatically.
     * <p>
     * If zero, sender selects packet encoding automatically based on {@code frameEncoding}.
     * This automatic selection matches only encodings that have exact same sample rate and
     * channel layout, and hence don't require conversions. If you need conversions, you
     * should set packet encoding explicitly.
     * <p>
     * If you want to force specific packet encoding, and built-in set of encodings is not
     * enough, you can use {@link RocContext#registerEncoding()} to register custom encoding,
     * set {@code packetEncoding} to registered identifier. If you use signaling protocol
     * like RTSP, it's enough to register in just on sender; otherwise, you need to do the
     * same on receiver as well.
     */
    private PacketEncoding packetEncoding;

    /**
     * The length of the packets produced by sender, in nanoseconds.
     * <p>
     * Number of nanoseconds encoded per packet. The samples written to the sender are
     * buffered until the full packet is accumulated or the sender is flushed or closed.
     * Larger number reduces packet overhead but also increases latency. If zero, default
     * value is used.
     */
    private Duration packetLength;

    /**
     * Enable packet interleaving.
     * <p>
     * If non-zero, the sender shuffles packets before sending them. This may increase
     * robustness but also increases latency.
     */
    private int packetInterleaving;

    /**
     * FEC encoding to use.
     * <p>
     * If non-zero, the sender employs a FEC encoding to generate redundant packets which may
     * be used on receiver to restore lost packets. This requires both sender and receiver to
     * use two separate source and repair endpoints.
     */
    private FecEncoding fecEncoding;

    /**
     * Number of source packets per FEC block.
     * <p>
     * Used if some FEC encoding is selected.
     * <p>
     * Sender divides stream into blocks of N source (media) packets, and adds M repair
     * (redundancy) packets to each block, where N is {@code fecBlockSourcePackets} and M is
     * {@code fecBlockRepairPackets}.
     * <p>
     * Larger number of source packets in block increases robustness (repair ratio), but also
     * increases latency.
     * <p>
     * If zero, default value is used.
     */
    private int fecBlockSourcePackets;

    /**
     * Number of repair packets per FEC block.
     * <p>
     * Used if some FEC encoding is selected.
     * <p>
     * Sender divides stream into blocks of N source (media) packets, and adds M repair
     * (redundancy) packets to each block, where N is {@code fecBlockSourcePackets} and M is
     * {@code fecBlockRepairPackets}.
     * <p>
     * Larger number of repair packets in block increases robustness (repair ratio), but also
     * increases traffic. Number of repair packets usually should be 1/2 or 2/3 of the number
     * of source packets.
     * <p>
     * If zero, default value is used.
     */
    private int fecBlockRepairPackets;

    /**
     * Clock source to use.
     * <p>
     * Defines whether write operation will be blocking or non-blocking. If zero, default
     * value is used ( {@link ClockSource#EXTERNAL} ).
     */
    private ClockSource clockSource;

    /**
     * Resampler backend to use.
     * <p>
     * If zero, default value is used.
     */
    private ResamplerBackend resamplerBackend;

    /**
     * Resampler profile to use.
     * <p>
     * If non-zero, the sender employs resampler if the frame sample rate differs from the
     * packet sample rate.
     */
    private ResamplerProfile resamplerProfile;

    /**
     * Construct lombok builder for {@link RocSenderConfig}.
     */
    public static RocSenderConfig.Builder builder() {
        return new RocSenderConfigValidator();
    }
}
